<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Grid Madness</title>
  <meta name="description" content="Grid Madness">
  <meta name="author" content="Steven">

  <style>
    .canvas-container{
      display: flex;
      justify-content: center;
    }
  </style>

  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <h1>Grid Madness!</h1>
  <p>Can our robot find the way through?</p>
  <div class="canvas-container">
    <canvas id="canvas-grid" width="610" height="610"></canvas>
  </div>
  <script>
    // TODO: Implement Draw Path
    const gridLength = 600;
    const gridSize = 10;
    const stepLength = gridLength / gridSize;
    const gridOffset = 5; // The grid is 5 pixels off from the actual 0,0 point of the canvas
    let canvas = document.getElementById("canvas-grid");
    let ctx = canvas.getContext("2d");
    let obstacles = [];
    const startCoord = { x: 0, y:0 };
    const endCoord = { x: 9, y:9 };


    function init() {
      window.requestAnimationFrame(draw);
    }

    function draw() {
      ctx.clearRect(0,0,610,610);
      drawGridLines();
      drawStart();
      drawEnd();
      drawObstacles();
    }

    function drawGridLines() {
      const start = gridOffset;
      const end = gridLength + gridOffset;

      // Draw Horizontal lines
      for(let y = start; y <=end; y += stepLength) {
        ctx.moveTo(start,y);
        ctx.lineTo(end,y);
        ctx.stroke();
      }

      // Draw Vertical lines
      for(let x = start; x <=end; x += stepLength) {
        ctx.moveTo(x,start);
        ctx.lineTo(x,end);
        ctx.stroke();
      }
    };

    function drawStart() {
      ctx.fillStyle = 'rgba(0, 97, 255, .5)';
      ctx.fillRect(gridOffset+1, gridOffset+1, stepLength-2, stepLength-2);
    };

    function drawEnd() {
      ctx.fillStyle = 'rgba(255, 0, 0, .5)';
      ctx.fillRect(gridLength+gridOffset+1-stepLength, gridLength+gridOffset+1-stepLength, stepLength-2, stepLength-2);
    };

    function drawObstacles() {
      ctx.fillStyle = 'darkgray';
      obstacles.forEach(obstacle => {
        const startCornerX = obstacle.x * stepLength + gridOffset + 1;
        const startCornerY = obstacle.y * stepLength + gridOffset + 1;
        ctx.fillRect(startCornerX, startCornerY, stepLength - 2, stepLength - 2); 
      });
    };

    function convertToGridElement(xPos, yPos) {
      const x = Math.floor(xPos/stepLength);
      const y = Math.floor(yPos/stepLength);
      return { x: x, y: y };
    };

    function togglePoint(point) {
      if(areEqualPoints(startCoord, point) || areEqualPoints(endCoord, point)) {
        return;
      }
      const index = obstacles.findIndex(obstacle => {
        return areEqualPoints(obstacle, point);
      });

      if(index === -1) {
        obstacles.push(point);
      } else {
        obstacles.splice(index, 1);
      }
    };

    function areEqualPoints(pointA, pointB) {
      return pointA.x === pointB.x && pointA.y === pointB.y;
    }

    // Event Listeners
    canvas.addEventListener('click', function(e) {
      const coordinate = convertToGridElement(e.offsetX - gridOffset, e.offsetY - gridOffset);
      togglePoint(coordinate);
      window.requestAnimationFrame(draw);
    });

    init();

  </script>
</body>
</html>