<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Grid Madness</title>
  <meta name="description" content="Grid Madness">
  <meta name="author" content="Steven">

  <style>
    .canvas-container{
      display: flex;
      justify-content: center;
    }
  </style>

  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <h1>Grid Madness!</h1>
  <p>Can our robot find the way through?</p>
  <div class="canvas-container">
    <canvas id="canvas-grid" width="610" height="610"></canvas>
  </div>
  <div>
    <p>Find the shortest path:</p>
    <button id="search-button">
      Search
    </button>
  </div> 
  <script>
    // TODO: Create a more efficient system for adding/removing obstacles
    // Try only drawing/erasing the obstacle that is being added/removed
    // TODO: Standardize language around grid coordinates and pixel position
    const gridLength = 600;
    const gridSize = 10;
    const stepLength = gridLength / gridSize;
    const gridOffset = 5; // The grid is 5 pixels off from the actual 0,0 point of the canvas
    let canvas = document.getElementById("canvas-grid");
    let ctx = canvas.getContext("2d");
    let obstacles = [];
    const startCoord = { x: 0, y:0 };
    const endCoord = { x: 9, y:9 };
    const pathPoints = [
      {x: 0, y: 0},
      {x: 1, y: 1},
      {x: 2, y: 2},
      {x: 3, y: 3},
      {x: 4, y: 4},
      {x: 5, y: 5},
      {x: 6, y: 6},
      {x: 7, y: 7},
      {x: 8, y: 8},
      {x: 9, y: 9}
    ];

    function init() {
      window.requestAnimationFrame(draw);
    };

    function draw() {
      ctx.clearRect(0,0,610,610);
      drawGridLines();
      drawStart();
      drawEnd();
      drawObstacles();
    };

    function drawGridLines() {
      const start = gridOffset;
      const end = gridLength + gridOffset;
      ctx.strokeStyle = 'black';

      // Draw Horizontal lines
      for(let y = start; y <=end; y += stepLength) {
        ctx.beginPath();
        ctx.moveTo(start,y);
        ctx.lineTo(end,y);
        ctx.stroke();
      }

      // Draw Vertical lines
      for(let x = start; x <=end; x += stepLength) {
        ctx.beginPath();
        ctx.moveTo(x,start);
        ctx.lineTo(x,end);
        ctx.stroke();
      }
    };

    function drawStart() {
      ctx.fillStyle = 'rgba(0, 97, 255, .5)';
      ctx.fillRect(gridOffset+1, gridOffset+1, stepLength-2, stepLength-2);
    };

    function drawEnd() {
      ctx.fillStyle = 'rgba(255, 0, 0, .5)';
      ctx.fillRect(gridLength+gridOffset+1-stepLength, gridLength+gridOffset+1-stepLength, stepLength-2, stepLength-2);
    };

    function drawObstacles() {
      ctx.fillStyle = 'darkgray';
      obstacles.forEach(obstacle => {
        const startCornerX = obstacle.x * stepLength + gridOffset + 1;
        const startCornerY = obstacle.y * stepLength + gridOffset + 1;
        ctx.fillRect(startCornerX, startCornerY, stepLength - 2, stepLength - 2); 
      });
    };

    // TODO: Use pathPoints to draw line
    function drawPathLine() {
      ctx.strokeStyle = 'red';
      ctx.lineCap = 'round';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(gridOffset + (stepLength/2), gridOffset + (stepLength/2));
      ctx.lineTo(gridOffset + stepLength + (stepLength/2), gridOffset + stepLength + (stepLength/2));
      ctx.stroke();
    };

    function convertToGridElement(xPos, yPos) {
      const x = Math.floor(xPos/stepLength);
      const y = Math.floor(yPos/stepLength);
      return { x: x, y: y };
    };

    // TODO: Write actual grid conversion equation
    function convertGridPointsToCanvasPosition(gridPoint) {
      const x = 10;
      const y = 10;
      return { x: x, y: y }
    }

    function togglePoint(point) {
      if(areEqualPoints(startCoord, point) || areEqualPoints(endCoord, point)) {
        return;
      }
      const index = obstacles.findIndex(obstacle => {
        return areEqualPoints(obstacle, point);
      });

      if(index === -1) {
        obstacles.push(point);
      } else {
        obstacles.splice(index, 1);
      }
    };

    function areEqualPoints(pointA, pointB) {
      return pointA.x === pointB.x && pointA.y === pointB.y;
    }

    // Event Listeners
    canvas.addEventListener('click', function(e) {
      const coordinate = convertToGridElement(e.offsetX - gridOffset, e.offsetY - gridOffset);
      togglePoint(coordinate);
      window.requestAnimationFrame(draw);
    });

    document.getElementById('search-button').addEventListener('click', function() {
      drawPathLine();
    });

    init();

  </script>
</body>
</html>