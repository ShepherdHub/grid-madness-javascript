<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Grid Madness</title>
  <meta name="description" content="Grid Madness">
  <meta name="author" content="Steven">

  <!-- Compiled and minified CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0-rc.2/css/materialize.min.css">
  <style>
    .logo {
      text-transform: uppercase;
      letter-spacing: 3px;
      font-size: 2.1rem;
      padding-left: 30px;
    }

    .main {
      padding-left: 30px;
      padding-right: 30px;
    }

    .flex-container {
      display: flex;
      flex-wrap: no-wrap;
    }

    section.canvas {
      flex-shrink: 0;
      flex-grow: 0;
    }

    section.options {
      flex-grow: 1;
      flex-shrink: 1;
      margin-top: 5px;
      margin-left: 15px;
      padding: 0 50px 0 10px;
      height: 500px;
      box-shadow: 0 2px 2px 0 rgba(0,0,0,0.14), 
                  0 3px 1px -2px rgba(0,0,0,0.12), 
                  0 1px 5px 0 rgba(0,0,0,0.2);
    }

    .button-group {
      display: flex;
      justify-content: space-between;
    }

    li {
      margin-bottom: 1em;
    }

    li>div {
      margin-bottom: 0.5em;
    }
  </style>

  <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.js"></script>
  <![endif]-->
</head>

<body>
  <nav>
    <div class="nav-wrapper indigo lighten-2">
      <a href="#" class="logo">Grid Madness!</a>
    </div>
  </nav>
  <div class="main">
    <p>Build an obstacle course and see if our Dijkstra-bot can find the shortest path.</p>

    <div class="flex-container">
    <section class="canvas">
      <canvas id="canvas-grid" width="510" height="510"></canvas>
    </section>
    <section class="options indigo lighten-5">
      <h5>Instructions:</h5>
      <ol>
        <li>Add obstacles by clicking squares on the grid. Clicking a square with an obstacle will remove the obstacle.</li>
        <li>
          <div>Choose a path finding alogrithm.</div>
          <div class="input-field">
            <select>
              <option value="dijkstra">Dijkstra's</option>
              <option value="d-star">D*</option>
              <option value="a-star">A*</option>
            </select>
          </div>
        </li>
        <li>
          <div>Find the shortest path!</div>
          <div class="button-group">
            <button id="draw-button" class="btn blue waves-effect">
              Find Path
            </button>
            <button id="clear-button" class="btn red waves-effect">
              Clear Path
            </button>
          </div>
        </li>
      </ol>
      <!-- <p>Click on an empty square to create an obstacle.</p>
      <p>Click on the square again to remove the obstacle.</p>
      <p>Find the shortest path:</p>
      <button id="draw-button" class="btn blue waves-effect">
        Find Path
      </button>
      <button id="clear-button" class="btn red waves-effect">
        Clear
      </button> -->
    </section>
    </div>
  </div>
  <script>
    /*************************************************************************
    *   Definitions
    * ---------------
    * Grid: 
    * The grid represents the possible spaces that an agent or an obstacle can occupy.
    * These spaces are called points and the position of the points is called a coordinate.
    * The grid is the abstracted field upon which the agent will explore. A 10x10 grid has
    * 10 rows and 10 columns of points. The grid state will be sent to the back end to compute
    * the path.
    *
    * Board:
    * The board represents the space on the html5 canvas upon which the grid is laid. The units
    * of the board are called pixels. The location of a pixel is called it's position. The board
    * represents the elements that are drawn onto the canvas. It is only a front end concept
    * used to draw on the canvas.
    *************************************************************************/

    const boardLength = 500;
    const gridSize = 10;
    const spaceLength = boardLength / gridSize;
    const boardOffset = 5.5; // The board is 5 pixels off from the actual 0,0 point of the canvas
    let canvas = document.getElementById("canvas-grid");
    let ctx = canvas.getContext("2d");
    let obstacles = [];
    const startPoint = { x: 0, y:0 };
    const endPoint = { x: 9, y:9 };
    const pathPoints = [
      {x: 0, y: 0},
      {x: 1, y: 0},
      {x: 1, y: 1},
      {x: 2, y: 2},
      {x: 3, y: 3},
      {x: 4, y: 4},
      {x: 5, y: 5},
      {x: 6, y: 6},
      {x: 7, y: 7},
      {x: 8, y: 8},
      {x: 9, y: 9}
    ];

    function init() {
      window.requestAnimationFrame(draw);
    };

    function draw() {
      clearBoard();
      drawGridLines();
      drawStart();
      drawEnd();
      drawObstacles();
    };

    function clearBoard() {
      ctx.clearRect(0, 0, 510, 510);
    };

    function drawGridLines() {
      const start = boardOffset;
      const end = boardLength + boardOffset;
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 1;

      // Draw Horizontal lines
      for(let y = start; y <=end; y += spaceLength) {
        ctx.beginPath();
        ctx.moveTo(start,y);
        ctx.lineTo(end,y);
        ctx.stroke();
      }

      // Draw Vertical lines
      for(let x = start; x <=end; x += spaceLength) {
        ctx.beginPath();
        ctx.moveTo(x,start);
        ctx.lineTo(x,end);
        ctx.stroke();
      }
    };

    function drawStart() {
      ctx.fillStyle = 'rgba(0, 97, 255, .5)';
      ctx.fillRect(boardOffset + 0.5, boardOffset + 0.5, spaceLength - 1, spaceLength - 1);
    };

    function drawEnd() {
      ctx.fillStyle = 'rgba(255, 0, 0, .5)';
      ctx.fillRect(
        boardLength + boardOffset + 0.5 - spaceLength, 
        boardLength + boardOffset + 0.5 - spaceLength,
        spaceLength - 1, 
        spaceLength - 1
      );
    };

    function drawObstacles() {
      ctx.fillStyle = 'darkgray';
      obstacles.forEach(obstacle => {
        const startCornerX = obstacle.x * spaceLength + boardOffset + 0.5;
        const startCornerY = obstacle.y * spaceLength + boardOffset + 0.5;
        ctx.fillRect(startCornerX, startCornerY, spaceLength - 1, spaceLength - 1); 
      });
    };

    function drawPathLine() {
      ctx.strokeStyle = 'red';
      ctx.lineCap = 'round';
      ctx.lineWidth = 3;

      if(pathPoints.length > 1) {
        ctx.beginPath();

        for(let i = 1; i < pathPoints.length; i++) {
          pathTimeout(i);
        }
      }
    };

    function pathTimeout(i) {
      setTimeout(function() {
        const start = convertGridPointToCanvasPosition(pathPoints[i-1]);
        const end = convertGridPointToCanvasPosition(pathPoints[i]);
        ctx.moveTo(start.x + (spaceLength / 2), start.y + (spaceLength / 2));
        ctx.lineTo(end.x + (spaceLength / 2), end.y + (spaceLength / 2));
        ctx.stroke();
      }, i * 300);
    };

    function convertPixelPositionToGridPoint(pos) {
      const x = Math.floor(pos.x / spaceLength);
      const y = Math.floor(pos.y / spaceLength);
      return { x: x, y: y };
    };

    // Converts a point to a position located at the top left corner of that point's space
    function convertGridPointToCanvasPosition(point) {
      const x = boardOffset + spaceLength * point.x;
      const y = boardOffset + spaceLength * point.y;
      return { x: x, y: y }
    }

    function togglePoint(point) {
      if(areEqualPoints(startPoint, point) || areEqualPoints(endPoint, point)) {
        return;
      }
      const index = obstacles.findIndex(obstacle => {
        return areEqualPoints(obstacle, point);
      });

      if(index === -1) {
        obstacles.push(point);
      } else {
        obstacles.splice(index, 1);
      }
    };

    function areEqualPoints(pointA, pointB) {
      return pointA.x === pointB.x && pointA.y === pointB.y;
    }

    // Event Listeners
    canvas.addEventListener('click', function(e) {
      const point = convertPixelPositionToGridPoint(
        { x: e.offsetX - boardOffset, y: e.offsetY - boardOffset }
      );
      togglePoint(point);
      window.requestAnimationFrame(draw);
    });

    document.getElementById('draw-button').addEventListener('click', function() {
      window.requestAnimationFrame(draw);
      window.requestAnimationFrame(drawPathLine);
    });

    document.getElementById('clear-button').addEventListener('click', function() {
      window.requestAnimationFrame(draw);
    });

    document.addEventListener('DOMContentLoaded', function() {
      var elems = document.querySelectorAll('select');
      var instances = M.FormSelect.init(elems);
    });


    init();

  </script>

  <!-- Compiled and minified JavaScript -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0-rc.2/js/materialize.min.js"></script>
</body>
</html>